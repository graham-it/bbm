;Commodore Machines Memory Map

;Version 1.12
;Released on October 29, 2025

;Copyright (c) 2025 Graham (Francesco Gramignani)
;https://graham-it.itch.io
;https://github.com/graham-it
;https://csdb.dk/scener/?id=40810

; --------------------
; - OS addresses
; --------------------

STATUS	= $90		;Kernal I/O Status Word (ST)
BASZPT	= $ff		;BASIC Temporary Data for Floating Point to ASCII Conversion
FBUFFR	= $100		;Work area for Floating Point to String Conversions (VIC-20/C64: 11 bytes) (C128/264: 16 bytes)
BASBUF	= $200		;[BUF] BASIC Line Editor Input Buffer (VIC-20/C64/264: 89 bytes) (C128: 161 bytes)
VERFCK	= $93		;Kernal LOAD/VERIFY flag (0 = LOAD, otherwise = VERIFY) (C128: Monitor operation flag, also)

!if target = 20 | target = 64 | target = 264 {
VERCK	= $0a		;BASIC LOAD/VERIFY flag (0 = LOAD, otherwise = VERIFY)
TXTTAB	= $2b		;Pointer to the Start of BASIC Program Text
VARTAB	= $2d		;Pointer to the Start of the BASIC Variables Storage Area / End BASIC Program Text (+1)
CURLIN	= $39		;Current BASIC Line Number (MSB = $ff, no line number)
DECCNT	= $5d		;Decimal point position used during the FOUT routine
FACHO	= $62		;FAC1 mantissa ($62-$65)
XSAV	= $97		;Temporary .X Register Save Area
}

!if target = 20 | target = 64 | target = 128 {
LDTND	= $98		;Number of Open I/O Files/Index to the End of File Tables
DFLTN	= $99		;Default Input Device
DFLTO	= $9a		;Default Output (CMD) Device
MSGFLG	= $9d		;Kernal Message Control Flag (0 = RUN mode, $80 = direct mode)
			;bits	7 = Kernal control messages
			; "	6 = Kernal error messages
			; "   5:0 = not used
SAL	= $ac		;Pointer to the starting address of a LOAD / Screen scrolling
EAL	= $ae 		;Pointer to Ending Address of Load (End of Program) (+1)
FADDR	= $ba		;[FA] Current Device Number (last used device)
ILOAD	= $330		;Indirect vector in Kernal LOAD routine
ISAVE	= $332		;Indirect vector in Kernal SAVE routine
}

!if target = 20 | target = 64 {
TXTPTR	= $7a		;Pointer to Current Text Character (into CHRGET routine)
LSTX	= $c5		;Matrix Coordinate of Last Key Pressed ($40 = none)
NDX	= $c6		;Number of characters in keyboard buffer
RVS	= $c7		;Reverse mode flag (0 = not active)
INDX	= $c8 		;Column of last nonspace character on logical line
SFDX	= $cb		;Matrix Coordinate of Current Key Pressed ($40 = none)
CRSW	= $d0		;Input source flag (0 = keyboard, otherwise = screen)
PNT	= $d1		;Pointer to the Address of the Current Screen Line
PNTR	= $d3		;Position of cursor on line
QTSW	= $d4		;Quote Mode Flag (0 = not active)
LNMX	= $d5		;Maximum Length of Physical Screen Line
TBLX	= $d6		;Current Cursor Physical Line Number
USER	= $f3		;Pointer to the Address of the Current Screen Color RAM Location
KEYTAB	= $f5		;Pointer to current Keyboard Decode Table
KEYD	= $277		;Keyboard buffer ($277-$280, 10 bytes)
MEMSTR	= $281		;Pointer to the Start of user memory
MEMSIZ	= $283		;[MEMHIGH] Pointer to the End of user memory (+1)
TXTCOL	= $286		;[COLOR] Current Foreground Color for Text
			;VIC-20				C64
			;bits 7:4 = not used		bits 7:4 = not used
			; "	3 = multicolor mode	 "   3:0 = color (16 values)
			; "   2:0 = color (8 values)
GDCOL	= $287		;Color of Character under Cursor
HIBASE	= $288		;Top Page of Screen Memory
XMAX	= $289		;Maximum Keyboard Buffer Size
SHFLAG	= $28d		;Shift key status flag (0 = none)
			;bits 7:3 = not used
			; "	2 = CTRL
			; "	1 = Commodore logo
			; "	0 = SHIFT
RPTFLG	= $28a		;Keyboard repeat flags (0 = only cursor, space, and INST/DEL repeating) (default = 0)
			;bits	7 = all keys repeat
			; "	6 = no keys repeat
			; "   5:0 = not used
KOUNT	= $28b		;Delay before other than first repeat of key (start value = 4)
DELAY	= $28c		;Delay before first repeat of key (start value = 16)
KEYLOG	= $28f		;Vector to Keyboard Table Setup Routine
SAREG	= $30c		;Storage Area for .A Register (Accumulator)
SXREG	= $30d		;Storage Area for .X Index Register
SYREG	= $30e		;Storage Area for .Y Index Register
SPREG	= $30f		;Storage Area for .P (Status) Register
TBUFFR	= $33c		;Cassette I/O Buffer ($33c-$3fb, 192 bytes)
}
;target = 20 | target = 64

!if target = 64 {
LDTB1	= $d9		;Screen line link table (25 bytes)
LNKTMP	= $f2		;SAVE byte for screen line link table byte
LINTMP	= $2a5		;Temporary Index to the Next Line for Screen Scrolling
}

!if target = 128 {
BANK	= $02	 	;Target bank for JMPFAR and JSRFAR
PC	= $03		;Target address for JMPFAR and JSRFAR
SPREG	= $05		;[S_REG] Status register storage for JMPFAR and JSRFAR
SAREG	= $06		;[A_REG] Accumulator storage for JMPFAR and JSRFAR
SXREG	= $07		;[X_REG] X register storage for JMPFAR and JSRFAR
SYREG	= $08		;[Y_REG] Y register storage for JMPFAR and JSRFAR
STKPTR	= $09		;Stack pointer storage for JSRFAR and monitor
VERCK	= $0c		;BASIC LOAD/VERIFY flag (0 = LOAD, otherwise = VERIFY)
INDEX	= $24		;Multipurpose address pointer (used by PRNSTR)
TXTTAB	= $2d		;Pointer to the Start of BASIC Program Text
VARTAB	= $2f		;Pointer to the Start of the BASIC Variables Storage Area
CURLIN	= $3b		;Current BASIC Line Number (MSB = $ff, no line number)
DECCNT	= $5f		;Decimal point position used during the FOUT routine
FACHO	= $64		;FAC1 mantissa ($64-$67)
RUNMOD	= $7f		;BASIC RUN mode flag (0 = immediate/direct mode)
			;bits	7 = a BASIC program is being executed
			; "	6 = a program is being loaded for execution
			; "   5:0 = not used
BA	= $c6		;Bank where data for save, load, or verify is found (default = 0)
FNBANK	= $c7		;Bank where file name for open, save, load, or verify is found (default = 15)
KEYTAB	= $cc		;Pointer to current Keyboard Decode Table
NDX	= $d0		;Number of characters in keyboard buffer
KYNDX	= $d1		;Number of characters pending from programmable key string
KEYIDX	= $d2		;Pointer into the programmable key definition area
SHFLAG	= $d3		;Shift key status flag (0 = none)
			;bits	7 = extra characters read using the VIC chip lines are being scanned
			; "   6:5 = not used
			; "	4 = CAPS LOCK
			; "	3 = ALT
			; "	2 = CTRL
			; "	1 = Commodore logo
			; "	0 = SHIFT
SFDX	= $d4		;Current key pressed ($58 = none)
LSTX	= $d5		;Last key pressed ($58 = none)
CRSW	= $d6		;Input source flag (0 = keyboard, otherwise = screen)
MODE	= $d7		;Active screen flag (bit 7)
			;clear = 40-columns (VIC-II)
			;set   = 80-columns (VDC)
PNT	= $e0		;Pointer to the Address of the Current Screen Line
USER	= $e2		;Pointer to first attribute memory location for current line
SCBOT	= $e4		;Bottom margin of current window
SCTOP	= $e5		;Top margin of current window
SCLF	= $e6		;Left margin of current window
SCRT	= $e7		;Right margin of current window
INDX	= $ea 		;Column of last nonspace character on logical line
TBLX	= $eb		;Cursor row
PNTR	= $ec		;Position of cursor within current physical line
TXTCOL	= $f1		;[COLOR] Attributes of current character
			;40-columns (VIC-II)	80-columns (VDC)
			;bits 7:4 = not used	bits	7 = character set (0 = uppercase, 1 = lowercase)
			; "   3:0 = color code	 "	6 = reversed
			;			 "	5 = underlined
			;			 "	4 = flashing
			;			 "	3 = red
			;			 "	2 = green
			;			 "	1 = blue
			;			 "	0 = intensity
RVS	= $f3		;Reverse mode flag (0 = not active)
QTSW	= $f4		;Quote Mode Flag (0 = not active)
SAVEA	= $110		;Temp storage for .A during I/O
SAVEY	= $111		;Temp storage for .Y during I/O
SAVEX	= $112		;Temp storage for .X during I/O
KEYVEC	= $33a		;Indirect vector in keyboard scanning routine (default = $c5e1)
KEYCHK	= $33c		;Indirect vector in keyboard scanning routine (default = $c6ad)
DECODE	= $33e		;Keyboard table pointers (six 2-byte pointers, default as KEYPTRS table at $c06f)
KEYD	= $34a		;[KEYBUF] Keyboard buffer ($34a-$353, 10 bytes)
CURBANK	= $3d5		;Bank number for BASIC operations (default = 15)
SAREG	= $7f2		;Storage Area for .A Register (Accumulator)
SXREG	= $7f3		;Storage Area for .X Index Register
SYREG	= $7f4		;Storage Area for .Y Index Register
SPREG	= $7f5		;Storage Area for .P (Status) Register
INITST	= $a04		;System initialization status flag (set = done)
			;bits	7 = VDC character set (copy from ROM into VDC private RAM)
			; "	6 = Keyboard Table Pointers and Function Key definitions
			; "   5:1 = not used
			; "	0 = cold start
MEMSTR	= $a05		;Pointer to the Start of user memory (in block 0 RAM)
MEMSIZ	= $a07		;Pointer to the End of user memory (+1) (in block 0 RAM)
RPTFLG	= $a22		;Keyboard repeat flags (0 = only cursor, space, and INST/DEL repeating) (default = $80)
			;bits	7 = all keys repeat
			; "	6 = no keys repeat
			; "   5:0 = not used
KOUNT	= $a23		;Delay before other than first repeat of key (start value = 4)
DELAY	= $a24		;Delay before first repeat of key (start value = 16)
TBUFFR	= $b00		;Cassette I/O Buffer ($b00-$bbf, 192 bytes) and Disk Boot Buffer ($b00-$bff, 256 bytes)
PKYBUF	= $1000		;Programmable Function Key lengths ($1000-$1009, 10 bytes)
PKYDEF	= $100a		;Programmable Function Key strings ($100a-$10ff, 246 bytes)
DOSSTR	= $1100		;DOS command assembly area ($1100-$1130, 49 bytes)
TXTTOP	= $1210		;Pointer to the End of BASIC Program Text (+1)
}
;target = 128

!if target = 264 {
RUNMOD	= $81		;BASIC RUN mode flag (0 = direct mode, $80 = a BASIC program is running)
XSAV	= $96		;Temporary .X Register Save Area
LDTND	= $97		;Number of Open I/O Files/Index to the End of File Tables
DFLTN	= $98		;Default Input Device
DFLTO	= $99		;Default Output (CMD) Device
MSGFLG	= $9a		;Kernal Message Control Flag (0 = RUN mode, $80 = direct mode)
			;bits	7 = Kernal control messages
			; "	6 = Kernal error messages
			; "   5:0 = not used
SAL	= $9b		;Pointer to the starting address of a LOAD / Screen scrolling
EAL	= $9d 		;Pointer to Ending Address of Load (End of Program) (+1)
FADDR	= $ae		;[FA] Current Device Number (last used device)
SFDX	= $c6		;Current key pressed ($40 = none)
CRSW	= $c7		;Input source flag (0 = keyboard, otherwise = screen)
PNT	= $c8		;Pointer to the Address of the Current Screen Line
PNTR	= $ca		;Position of cursor within current physical line
QTSW	= $cb		;Quote Mode Flag (0 = not active)
TBLX	= $cd		;Cursor row
USER	= $ea		;Pointer to the Address of the Current Screen Color RAM Location
KEYTAB	= $ec		;Pointer to current Keyboard Decode Table
NDX	= $ef		;Number of characters in keyboard buffer
ILOAD	= $32e		;Indirect vector in Kernal LOAD routine
ISAVE	= $330		;Indirect vector in Kernal SAVE routine
TBUFFR	= $332		;Cassette I/O Buffer ($332-$3f2, 193 bytes)
KEYD	= $527		;[KEYBD] Keyboard buffer ($527-$530, 10 bytes)
MEMSTR	= $531		;Pointer to the Start of user memory
MEMSIZ	= $533		;[MSIZ] Pointer to the End of user memory (+1)
TXTCOL	= $53b		;[COLOR] Current character luminance/color
			;bits	7 = flashing
			; "   6:4 = luminance (8 values)
			; "   3:0 = color (16 values)
HIBASE	= $53e		;Top Page of Screen Memory
RPTFLG	= $540		;Keyboard repeat flags (0 = only cursor, space, and INST/DEL repeating) (default = $80)
			;bits	7 = all keys repeat
			; "	6 = no keys repeat
			; "   5:0 = not used
KOUNT	= $541		;Delay before other than first repeat of key (start value = 4)
DELAY	= $542		;Delay before first repeat of key (start value = 16)
SHFLAG	= $543		;Shift key status flag (0 = none)
			;bits 7:3 = not used
			; "	2 = CTRL
			; "	1 = Commodore logo
			; "	0 = SHIFT
KYNDX	= $55d		;Number of characters left to get from Function Key definition
KEYIDX	= $55e		;Pointer to current character in Function Keys definition
PKYBUF	= $55f		;[KEYBUF] Programmable Function Key lengths ($55f-$566, 8 bytes)
PKYDEF	= $567		;[PKYBUF] Programmable Function Key strings ($567-$5e6, 128 bytes)
SCBOT	= $7e5		;Bottom margin of current window
SCTOP	= $7e6		;Top margin of current window
SCLF	= $7e7		;Left margin of current window
SCRT	= $7e8		;Right margin of current window
LSTX	= $7f6		;Last key pressed ($40 = none)
}
;target = 264

; --------------------
; - I/O devices
; --------------------

!if target = 20 {
RASTERL	= $9003		;[VICCR3] Number of character lines displayed, part of raster location
			;bits	7 = low order bit [0] of Raster beam location ($9004)
			; "   6:1 = number of character lines multiplied by two (default = 46)
			; "	0 = character size (clear = 8 x 8 (deafault), set = 8 x 16 pixels)
RASTERH	= $9004		;[VICCR4] Raster beam location (high order bits [8:1])
VICCRF	= $900f		;Background color, border color, inverse color switch
			;bits 7:4 = background color (default = 1, white)
			; "	3 = inverse color switch (default = set)
			; "   2:0 = border color (default = 3, cyan)
VIAPRB	= $9110		;VIA #1 Port B I/O register
VIAPRA	= $9111		;VIA #1 Port A I/O register (joy input: except right direction)
VIDDRB	= $9112		;VIA #1 Data direction register for Port B
VIDDRA	= $9113		;VIA #1 Data direction register for Port A
VIAIER	= $911e		;VIA #1 Interrupt enable register (IER)
VIAPA2	= $911f		;Mirror of VIA #1 Port A I/O register ($9111)
VI2PRB	= $9120		;VIA #2 Port B I/O register (joy input: right direction only)
VI2PRA	= $9121		;VIA #2 Port A I/O register
V2DDRB	= $9122		;VIA #2 Data direction register for Port B
V2DDRA	= $9123		;VIA #2 Data direction register for Port A
VI2IER	= $912e		;VIA #2 Interrupt enable register (IER)
VI2PA2	= $912f		;Mirror of VIA #2 Port A I/O register ($911f)
}
;target = 20

!if target = 64 | target = 128 {
RASTERH	= $d011		;[SCROLY] Vertical Fine Scrolling and Control Register
			;bits	7 = High bit [8] of raster compare register ($d012)
			; "	6 = Enable extended color text mode (set = enabled)
			; "	5 = Enable bitmap graphics mode (set = enabled)
			; "	4 = Blank the entire screen to the same color as the border (clear = blank)
			; "	3 = Select a 24-row or 25-row text display (set = 25 (default), clear = 24 rows)
			; "   2:0 = Fine scroll display vertically by X scan lines (0-7)
RASTERL	= $d012		;Raster compare register (low order bits [7:0])
SCROLX	= $d016		;Horizontal fine Scrolling and Control Register
			;bits 7:6 = not used
			; "	5 = Video chip reset (clear = normal operation, set = video completely off)
			; "	4 = Enable multicolor text or multicolor bitmap mode (clear = off (default), set = on)
			; "	3 = Select a 38-column or 40-column text display (set = 40 (default), clear = 38 columns)
			; "   2:0 = Fine scroll display horizontally by X dot positions (0-7)
EXTCOL	= $d020		;VIC-II Border color register
BGCOL0	= $d021		;VIC-II Background color register
CIAPRA	= $dc00		;CIA #1 Data Port Register A (keyboard columns and joystick in port #2)
CIAPRB	= $dc01		;CIA #1 Data Port Register B (keyboard rows and joystick in port #1)
CIDDRA	= $dc02		;CIA #1 Data Direction Register A (default = $ff, all bits as output)
CIDDRB	= $dc03		;CIA #1 Data Direction Register B (default = $00, all bits as input)
}
;target = 64 | target = 128

!if target = 128 {
XSCAN	= $d02f		;Extended keyboard scan-line control register
			;bits 7:3 = not used
			; "   2:0 = keyboard columns containing the 24 additional keys of the C128
CLKRATE	= $d030		;Processor clock rate control register
			;bits 7:2 = not used
			; "	1 = test bit (default = 0, setting this bit to 1 will blank the 40-column screen display)
			; "	0 = processor clock speed (clear = 1 MHz, set = 2 MHz)
VDCADR	= $d600		;VDC Address/status register
			;bits	7 = STATUS flag (clear = ready to read/write access)
			; "	6 = LP flag (set = light pen latched)
			; "	5 = VBLANK flag (set = raster scan is in its vertical blank period)
			; "   4:3 = not used
			; "   2:0 = version number of the VDC chip
VDCDAT	= $d601		;VDC Data register
MMUCR	= $ff00		;MMU Configuration Register (mirror of $d500)
			;bits 7:6 = RAM block selection (Expansion RAM blocks 2 and 3 not implemented)
			;		00 System RAM block 0		01 System RAM block 1
			;		10 Expansion RAM block 2	11 Expansion RAM block 3
			; "   5:4 = High Space memory ($c000-$ffff)
			;		00 = Kernal & Character ROM	01 = Internal Function ROM
			;		10 = External Function ROM	11 = RAM
			; "   3:2 = Mid Space memory ($8000-$bfff)
			;		00 = BASIC High ROM & Monitor	01 = Internal Function ROM
			;		10 = External Function ROM	11 = RAM
			; "	1 = Low Space memory ($4000-$7fff)
			;		0 = BASIC Low ROM		1 = RAM
			; "	0 = I/O Space ($d000-$dfff) (overrides bits 5:4)
			;		0 = I/O Registers		1 = RAM or ROM (depending on bits 5:4)

;Load Configuration Registers (store any value to activate the corresponding Preconfiguration Register)
LCRA	= $ff01		;$3f = BANK  0	RAM block 0 ($0000-$ffff) no ROMs available
LCRB	= $ff02		;$7f =  "    1	RAM  "    1 ($0000-$ffff) no ROMs available
LCRC	= $ff03		;$01 =  "   14	RAM  "    0 ($0000-$3fff) System ROMs (I/O Registers not available)
LCRD	= $ff04		;$41 = same as BANK 14, but with RAM from block 1 instead of 0

;NOTE, in all Banks:
;locations $00 and $01 are the 8502 Processor's on-chip I/O Port Direction and Data Registers
;locations $ff00-$ff04 are MMU Configuration Register and Load Configuration Registers
}
;target = 128

!if target = 264 {
PIOKEY	= $fd30		;Keyboard Columns Output Latch Register (SPI 6529B)
TEDKEY	= $ff08		;Keyboard Rows Input Latch Register
			;bits 7:0 = keyboard rows data
			; "     7 = joystick button in port #2
			; "     6 = joystick button in port #1
			; "   3:0 = joystick directions
			; "	2 = clear to latch joystick in port #1
			; "	1 = clear to latch joystick in port #2
TEDIRQH	= $ff0a		;Interrupt enable register
			;bits	7 = not connected
			; "	6 = timer 3 interrupt enable
			; "	5 = not connected
			; "	4 = timer 2 interrupt enable
			; "	3 = timer 1 interrupt enable
			; "	2 = light pen interrupt enable
			; "	1 = raster interrupt enable
			; "	0 = high bit [8] of Raster interrupt value ($ff0b)
TEDIRQL	= $ff0b		;Raster interrupt value (low order bits [7:0])
TEDCURH	= $ff0c		;Hardware cursor position (beyond 999 cursor is not visible)
			;bits 7:2 = not used
			; "   1:0 = high order bits [9:8]
TEDCURL	= $ff0d		;Hardware cursor position (low order bits [7:0])
RASTERH	= $ff1c		;Current raster line (high bit)
			;bits 7:1 = not connected (always high)
			; "	0 = high bit [8] of Current raster line ($ff1d)
RASTERL	= $ff1d		;Current raster line (low order bits [7:0])
BGCOL0	= $ff15		;Background color register (default = $f1, white)
EXTCOL	= $ff19		;Border color register (default = $ee, violet)
}
;target = 264

; --------------------
; - BASIC routines
; --------------------

!if target = 20 {
READY	= $c474		;Display READY message, then fall into Main BASIC Loop
LNKPRG	= $c533		;Relink lines of tokenized program text
INLIN	= $a560		;[GETLIN] Input a Line to Buffer from Keyboard (string + $00 -> BASBUF)
CRUNCH	= $a579		;[CRNCH] Tokenize Line in Input Buffer
SCRATH	= $c642		;Perform NEW (condition: zero bit clear)
SCRTCH	= $c644		;Perform NEW (unconditional, then continue with RUNC)
RUNC	= $c659		;Reset CHRGET pointer and Perform CLR
CLEAR	= $c65e		;Perform CLR (condition: zero bit clear)
CLEARC	= $c660		;Perform CLR (unconditional, then continue with STKINI)
STKINI	= $c67a		;Reset the Stack Pointer (returns with a = 0)
STXTPT	= $c68e		;Reset Pointer to Current Text Character to the Beginning of Program Text
NEWSTT	= $c7ae		;Set up next statement for execution (BASIC Interpreter Loop)
GONE	= $c7e4 	;Read and Execute Next Statement
GONE3	= $c7ed		;Execute a BASIC Statement
GOCR	= $cad7		;Print a Carriage Return (if LFN is greater than 128, also print a Line Feed)
PRNSTR	= $cb1e		;[STROUT] Print string in A/Y (result: a = last printed char, x = 0, y = printed chars, zero set)
MOVERT	= $cb42		;Move cursor right (result: a = not preserved)
GIVAYF	= $d391		;[MAKFP] Convert 16-bit signed integer to Floating Point (A/Y = MSB/LSB, result in FAC1)
FLOATS	= $dc44		;[INTFP1] Convert 16-bit signed integer to Floating Point (FACHO/FACHO+1 = MSB/LSB, result in FAC1)
FLOATC	= $dc49		;Convert 16-bit unsigned integer to Floating Point (FACHO/FACHO+1 = MSB/LSB, result in FAC1)
PRNINT	= $ddcd		;[PRTFIX] Print 16-bit unsigned integer in A/X (MSB/LSB) (result: y = printed chars)
FOUT	= $dddd		;[FLTASC] Convert the contents of FAC1 into an ASCII string (at FBUFFR)
FOUTC	= $dddf		;Convert the contents of FAC1 into an ASCII string (at FBUFFR) (without initial space)
CLOAD	= $e165		;[BLOAD] Perform LOAD
CLOAD2	= $e16c		;Perform LOAD (with parameters already set)
PLSV	= $e1d1		;[PARSL] Set Parameters for LOAD, VERIFY, and SAVE
COLDBAS	= $e378		;BASIC cold start
INITCZ	= $e3a4		;Initialize BASIC RAM
FREMSG	= $e404		;Display BASIC start-up messages, then perform NEW
INITV	= $e45b		;Initialize BASIC Vectors
WARMBAS	= $e467		;BASIC warm start
}
;target = 20

!if target = 64 {
READY	= $a474		;Display READY message, then fall into Main BASIC Loop
LNKPRG	= $a533		;Relink lines of tokenized program text
INLIN	= $a560		;Input a Line to Buffer from Keyboard (string + $00 -> BASBUF)
CRUNCH	= $a579		;Tokenize Line in Input Buffer
SCRATH	= $a642		;Perform NEW (condition: zero bit clear)
SCRTCH	= $a644		;Perform NEW (unconditional, then continue with RUNC)
RUNC	= $a659		;Reset CHRGET pointer and Perform CLR
CLEAR	= $a65e		;Perform CLR (condition: zero bit clear)
CLEARC	= $a660		;Perform CLR (unconditional, then continue with STKINI)
STKINI	= $a67a		;Reset the Stack Pointer (returns with a = 0)
STXTPT	= $a68e		;[RUNC] Reset Pointer to Current Text Character to the Beginning of Program Text
NEWSTT	= $a7ae		;Set up next statement for execution (BASIC Interpreter Loop)
GONE	= $a7e4 	;Read and Execute Next Statement
GONE3	= $a7ed		;Execute a BASIC Statement
GOCR	= $aad7		;Print a Carriage Return (if LFN is greater than 128, also print a Line Feed)
PRNSTR	= $ab1e		;[STROUT] Print string in A/Y (result: a = last printed char, x = 0, y = printed chars, zero set)
MOVERT	= $ab42		;Move cursor right (result: a = not preserved)
GIVAYF	= $b391 	;Convert 16-bit signed integer to Floating Point (A/Y = MSB/LSB, result in FAC1)
FLOATS	= $bc44		;Convert 16-bit signed integer to Floating Point (FACHO/FACHO+1 = MSB/LSB, result in FAC1)
FLOATC	= $bc49		;Convert 16-bit unsigned integer to Floating Point (FACHO/FACHO+1 = MSB/LSB, result in FAC1)
PRNINT	= $bdcd		;[LINPRT] Print 16-bit unsigned integer in A/X (MSB/LSB) (result: y = printed chars)
FOUT	= $bddd		;Convert the contents of FAC1 into an ASCII string (at FBUFFR)
FOUTC	= $bddf		;Convert the contents of FAC1 into an ASCII string (at FBUFFR) (without initial space)
CLOAD	= $e168		;Perform LOAD
CLOAD2	= $e16f		;Perform LOAD (with parameters already set)
PLSV	= $e1d4		;Set Parameters for LOAD, VERIFY, and SAVE
WARMBAS	= $e37b		;BASIC warm start
COLDBAS	= $e394		;BASIC cold start
INITCZ	= $e3bf		;Initialize BASIC RAM
FREMSG	= $e422		;Display BASIC start-up messages, then perform NEW
INITV	= $e453		;Initialize BASIC Vectors
}
;target = 64

!if target = 128 {
;BASIC Low ROM
COLDBAS	= $4000		;BASIC cold start
WARMBAS	= $4003		;BASIC warm start
STRTMSG	= $419b		;Display BASIC start-up messages
GONE	= $4a9f		;Read and Execute Next Statement
NEWSTT	= $4af6		;Set up next statement for execution (BASIC Interpreter Loop)
GONE3	= $4b3f		;Execute a BASIC Statement
READY	= $4d37		;Display READY message, then fall into Main BASIC Loop
LNKPRG	= $4f4f		;Relink lines of tokenized program text
INLIN	= $4f93		;Input a Line to Buffer from Keyboard (string + $00 -> BASBUF)
SCRATH	= $51d6		;Perform NEW (condition: zero bit clear)
SCRTCH	= $51d9		;Perform NEW (unconditional, then continue with RUNC)
RUNC	= $51f3		;Reset CHRGET pointer and perform CLR
CLEAR	= $51f8		;Perform CLR (condition: zero bit clear)
CLEARC	= $51fa		;Perform CLR (unconditional, then continue with STKINI)
STKINI	= $5238		;Reset the Stack Pointer (returns with a = 0)
STXTPT	= $5254		;[RUNC] Reset Pointer to Current Text Character to the Beginning of Program Text
GOCR	= $5598		;Print a Carriage Return (if LFN is greater than 128, also print a Line Feed)
STROUT	= $55e2		;Print string in A/Y (result: a = last printed char, x = 0, y = printed chars, zero set)
			;(NOTE: the string must be located in RAM block 0)
SETEXC	= $5a81		;Set PROGRAM mode
RUNPRG	= $5aa6		;RUN a program after LOAD (SETEXC + RUNC + LNKPRG + PRINT <CR> + NEWSTT)
SETRUN	= $5ab5		;Set PROGRAM mode, reset CHRGET pointer and perform CLR (SETEXC + RUNC)
FAST	= $77b3		;Set clock frequency to 2 MHz
SLOW	= $77c4		;Set clock frequency to 1 MHz
GIVAYF	= $793c		;Convert 16-bit signed integer to Floating Point (A/Y = MSB/LSB, result in FAC1)

;BASIC High ROM
NOSFLT	= $84c9		;[GIVAYF1] Convert 16-bit unsigned integer to Floating Point (A/Y = MSB/LSB, result in FAC1)
STOINT	= $84e5		;[GIVAYF2] Set up parameters to convert 16-bit integer to Floating Point (A/Y = MSB/LSB)
			;(result: x = exponent to 2^16 ($90), FACHO/FACHO+1 = MSB/LSB)
FLOATS	= $8c70		;Convert 16-bit signed integer to Floating Point (FACHO/FACHO+1 = MSB/LSB, result in FAC1)
FLOATC	= $8c75		;Convert 16-bit unsigned integer to Floating Point (FACHO/FACHO+1 = MSB/LSB, result in FAC1)
LINPRT	= $8e32		;Print 16-bit unsigned integer in A/X (MSB/LSB) (result: y = printed chars)
FOUT	= $8e42		;Convert the contents of FAC1 into an ASCII string (at FBUFFR)
FOUTC	= $8e44		;Convert the contents of FAC1 into an ASCII string (at FBUFFR) (without initial space)
CLOAD	= $912c		;Perform LOAD
CLOAD2	= $9133		;Perform LOAD (with parameters already set)
PLSV	= $91ae		;Set Parameters for LOAD, VERIFY, and SAVE
BANK15	= $a845		;Enable all system ROMs (BANK 15) (a, x, y = preserved)
}
;target = 128

!if target = 264 {
COLDBAS	= $8000		;[CLDSTRT] BASIC cold start
WARMBAS	= $8003		;BASIC warm start
FREMSG	= $80c2		;[INITMS] Display BASIC start-up messages, then perform NEW
READY	= $867e		;Display READY message, then fall into Main BASIC Loop
LNKPRG	= $8818		;Relink lines of tokenized program text
SCRATH	= $8a79		;Perform NEW (condition: zero bit clear)
SCRTCH	= $8a7b		;Perform NEW (unconditional, then continue with RUNC)
RUNC	= $8a93		;Reset CHRGET pointer and perform CLR
CLEARC	= $8a9a		;Perform CLR (return: a = 0, stack restored)
STXTPT	= $8af1		;Reset Pointer to Current Text Character to the Beginning of Program Text
SETRUN	= $8bbe		;Set PROGRAM mode, reset CHRGET pointer and perform CLR (SETEXC + RUNC)
GONE	= $8bd3		;[XEQCM] Read and Execute Next Statement
NEWSTT	= $8bdc		;Set up next statement for execution (BASIC Interpreter Loop)
GONE3	= $8c25		;[XEQCM3] Execute a BASIC Statement
SETEXC	= $8d20		;Set PROGRAM mode
GOCR	= $903e		;[CRDO] Print a Carriage Return (if LFN is greater than 128, also print a Line Feed)
PRNSTR	= $9088		;[STROUT] Print string in A/Y (result: a = last printed char, x = 0, y = printed chars, zero set)
GIVAYF	= $9471		;Convert 16-bit signed integer to Floating Point (A/Y = MSB/LSB, result in FAC1)
NOSFLT	= $9a76		;Convert 16-bit unsigned integer to Floating Point (A/Y = MSB/LSB, result in FAC1)
STOINT	= $9a92		;Set up parameters to convert 16-bit integer to Floating Point (A/Y = MSB/LSB)
			;(result: x = exponent to 2^16 ($90), VALTYP = numeric ($00), FACHO/FACHO+1 = MSB/LSB)
FLOATS	= $a2c9		;Convert 16-bit signed integer to Floating Point (FACHO/FACHO+1 = MSB/LSB, result in FAC1)
FLOATC	= $a2ce		;Convert 16-bit unsigned integer to Floating Point (FACHO/FACHO+1 = MSB/LSB, result in FAC1)
PRNINT	= $a45f		;[LINPRT] Print 16-bit unsigned integer in A/X (MSB/LSB) (result: y = printed chars)
FOUT	= $a46f		;Convert the contents of FAC1 into an ASCII string (at FBUFFR)
FOUTC	= $a471		;Convert the contents of FAC1 into an ASCII string (at FBUFFR) (without initial space)
CLOAD	= $a7f3		;Perform LOAD
CLOAD2	= $a7fa		;Perform LOAD (with parameters already set)
PLSV	= $a86b		;Set Parameters for LOAD, VERIFY, and SAVE
}
;target = 264

; --------------------
; - BASIC tables
; --------------------

!if target = 20 {
;Miscellaneous Messages
BASMSG_ok	= $c364		;CR,"ok",CR,0
BASMSG_error	= $c369		;SP,SP,"error",0
BASMSG_in	= $c371		;SP,"in",SP,0
BASMSG_ready	= $c376		;CR,LF,"ready.",CR,LF,0
BASMSG_break	= $c381		;CR,LF,"break",0
}

!if target = 64 {
;Miscellaneous Messages
BASMSG_ok	= $a364		;CR,"ok",CR,0
BASMSG_error	= $a369		;SP,SP,"error",0
BASMSG_in	= $a371		;SP,"in",SP,0
BASMSG_ready	= $a376		;CR,LF,"ready.",CR,LF,0
BASMSG_break	= $a381		;CR,LF,"break",0
}

!if target = 128 {
;Miscellaneous Messages
BASMSG_break	= $4be8		;CR,LF,"break",0
BASMSG_ready	= $4d2d		;CR,"ready.",CR,0
BASMSG_error	= $4da8		;SP,"error",0
BASMSG_in	= $8e29		;SP,"in",SP,0
BASMSG_ok	= $915a		;CR,"ok",CR,0
}

!if target = 264 {
;Miscellaneous Messages
BASMSG_ready	= $8672		;CR,LF,"ready.",CR,LF,0
BASMSG_error	= $86f4		;SP,"error",0
BASMSG_break	= $8cf5		;CR,LF,"break",0
BASMSG_in	= $a456		;SP,"in",SP,0
BASMSG_ok	= $a81e		;CR,"ok",CR,0

;Joystick tables
JOYTAB	= $bff0		;Joystick direction table (11 bytes)
JOYBIT	= $bffb		;Joystick port latch values table (2 bytes)
}

; --------------------
; - Kernal routines
; --------------------

!if target = 20 | target = 64 {
INITSK	= $e518		;Initialize Screen and Keyboard (original CINT routine)
}

!if target = 20 {
CLRSCN	= $e55f		;Clear screen
HOME	= $e581 	;Move cursor to Home position
STUPT	= $e587		;Set Pointer to Current Screen Logical Line (TBLX, PNTR, LDTB1 -> PNT)
GETSCN	= $e64f		;[GETSCRN] Input a Character from Screen or Keyboard (depending on CRSW value)
NXLN	= $e8c3		;[NXTLINE] Move cursor to Next Line
SETPNT	= $ea7e		;[LINPTR] Set Pointer to Screen Address of Start of Line (x = line)
			;(result: PNT -> line in Screen RAM)
CLRLN	= $ea8d		;Clear screen line (x = line, preserved) (TBLX updated)
NEWLIN	= $e9ee		;[OPENLIN] Insert a Blank Line on the Screen (LDTB1 updated)
NEWLX	= $ea08		;Insert a Blank Line on the Screen (preparing: LINTMP = start line)
SCOLOR	= $eab2		;[COLORSYN] Synchronize Color RAM Pointer to Screen Line Pointer
			;(preparing: PNT -> line in Screen RAM) (result: USER -> line in Color RAM)
NLOAD	= $f549		;Standard entry point in Kernal LOAD routine
START1	= $fd2f		;Partial Reset (RAMTAS -> RESTOR -> IOINIT -> INITSK -> BASIC cold start)
START2	= $fd32		;Partial Reset (without RAMTAS)
RAMTAS	= $fd8d		;Perform RAM test and set pointers to the top and bottom of RAM
IOINIT	= $fdf9		;Initialize I/O Devices
WARMST	= $fed2		;Warm Start (RESTOR -> IOINIT -> INITSK -> BASIC warm start)
WARMST2	= $fed5		;Warm Start (without RESTOR)
}
;target = 20

!if target = 64 {
CLRSCN	= $e544		;Clear screen
HOME	= $e566 	;Move cursor to Home position
STUPT	= $e56c		;Set Pointer to Current Screen Logical Line (TBLX, PNTR, LDTB1 -> PNT, USER)
			;(zero bit clear, at exit)
INITVC	= $e5a0		;Initialize Video Controller
GETSCN	= $e632		;[LOOP5] Input a Character from Screen or Keyboard (depending on CRSW value)
NXLN	= $e87c		;Move Cursor to Next Line
NEWLIN	= $e965		;Insert a Blank Line on the Screen (LDTB1 updated)
NEWLNX	= $e96c		;[BMT2] Insert a Blank Line on the Screen (x = start line -> LINTMP)
			;(result: PNTR = #$28, LDTB1+LINTMP = linked to prev line, x = not preserved)
NEWLX	= $e981		;Insert a Blank Line on the Screen (preparing: LINTMP = start line)
			;(start line is linked to prev line) (start line = 0 -> LDTB1 must be fixed)
SETPNT	= $e9f0		;Set Pointer to Screen Address of Start of Line (x = line)
			;(result: PNT -> line in Screen RAM)
CLRLN	= $e9ff		;Clear screen line (x = line, preserved) (TBLX updated)
SCOLOR	= $ea24		;Synchronize Color RAM Pointer to Screen Line Pointer
			;(preparing: PNT -> line in Screen RAM) (result: USER -> line in Color RAM)
NLOAD	= $f4a5		;Standard entry point in Kernal LOAD routine
START1	= $fcef		;Partial Reset (IOINIT -> RAMTAS -> RESTOR -> CINT -> BASIC cold start)
START2	= $fcf8		;Partial Reset (without IOINIT and RAMTAS)
WARMST	= $fe66		;[TIMB] Warm Start (RESTOR -> IOINIT -> INITSK -> BASIC warm start)
WARMST2	= $fe69		;Warm Start (without RESTOR)
}
;target = 64

!if target = 128 {
CLRSCN	= $c142		;Clear screen
HOME	= $c150 	;Move cursor to Home position
SETPNT	= $c15e		;Set starting address pointers for a specified line (x = line)
			;(result: PNT -> line in Screen RAM, USER -> line in Attribute/Color RAM)
NXLN	= $c363		;[NEXTLIN] Move cursor to Next Line
CLRLN	= $c4a5		;Clear screen line (x = line, preserved) (NOTE: does not update TBLX)
REPEAT	= $c651		;Decode key matrix value into character value and handle key repeating
WINDOW	= $ca1b		;Set Window boundaries (CLC = top/left, SEC = bottom/right, a = row, x = column)
WINBOT	= $ca1d		;Set Window bottom/right boundaries (a = row, x = column)
WINTOP	= $ca2e		;Set Window top/left boundaries (a = row, x = column)
FULLW	= $ca24		;Reset Window to full screen size (HOME-HOME)
SCRLUP	= $cabc		;Scroll the display up one line (ESC V)
SCRLDN	= $caca		;Scroll the display down one line (ESC W)
NLOAD	= $f26c		;Standard entry point in Kernal LOAD routine
MMURES	= $f83b		;Enable all system ROMs (BANK 15) (a = not preserved) (part of ROM copy of JSRFAR)
WARMST	= $fa53		;Warm Start (RESTOR -> IOINIT -> CINT -> BASIC warm start)
WARMST2	= $fa56		;Warm Start (without RESTOR)

;Values for Indirect vector (KEYCHK at $33c) in keyboard scanning routine (REPEAT at $c651)
PFKON	= $c6ad		;Function Keys enabled (default, restored by CINT)
PFKOFF	= $c6b7		;Function Keys disabled (as on VIC-20/C64)

;VDC routines
WRITE80 = $cdca		;Write one byte to VDC chip memory (a = value) (a, y = preserved)
WRTREG	= $cdcc		;Write one byte to an VDC chip register (a = value, x = register) (a, x, y = preserved)
READ80	= $cdd8		;Read one byte from VDC chip memory (a = value) (y = preserved)
READREG	= $cdda		;Read one byte from an VDC chip register (a = value, x = register) (x, y = preserved)
SCNPOS	= $cde6		;Set current address in VDC screen memory (y = column offset)
			;(PNT -> current line in VDC screen memory) (y = preserved)
ATTRPOS	= $cdf9		;Set current address in VDC attribute memory (y = column offset)
			;(USER -> current line in VDC attribute memory) (y = preserved)
}
;target = 128

!if target = 264 {
NORMSCN	= $d888		;Reset full screen then clear (ESC N)
CLRSCN	= $d88b		;Clear screen
HOME	= $d89a 	;Move cursor to Home position
SETLINE	= $d8a1		;Set pointer to current screen line
CURADDR	= $d8a8		;Return the address of the cursor
SETPNT	= $d8aa		;Set starting address pointers for a specified line (x = line)
			;(result: PNT -> line in Screen RAM, USER -> line in Color RAM)
GETSCN	= $d965		;[LOOP5] Input a Character from Screen or Keyboard (depending on CRSW value)
NXLN	= $da21		;Move Cursor to Next Line
CLRLN	= $daf7		;Clear screen line (x = line, preserved) (NOTE: does not update TBLX)
WINBOT	= $de67		;Set Window bottom/right boundaries (a = row, x = column)
WINTOP	= $de7a		;Set Window top/left boundaries (a = row, x = column)
FULLW	= $de70		;Reset Window to full screen size (HOME-HOME)
SCRLUP	= $def6		;Scroll the display up one line (ESC V)
SCRLDN	= $df04		;Scroll the display down one line (ESC W)
NLOAD	= $f04a		;Standard entry point in Kernal LOAD routine
}
;target = 264

; --------------------
; - Kernal tables
; --------------------

!if target = 20 {
KEYPTRS	= $ec46		;[KEYVCTRS] Keyboard Decode Table Vectors (8 bytes)
KEYSTD	= $ec5e		;[NORMKEYS] Standard Keyboard Matrix Decode Table
KEYSHFT	= $ec9f		;[SHFTKEYS] SHIFTed Keyboard Matrix Decode Table
KEYLOGO	= $ece0		;[LOGOKEYS] Commodore Logo Keyboard Matrix Decode Table
KEYCTRL	= $eda3		;[CTRLKEYS] Control Keyboard Matrix Decode Table
RUNTB	= $edf4		;LOAD and RUN first file on tape (SHIFT + RUN/STOP command string)
}
;target = 20

!if target = 64 {
KEYPTRS	= $eb79		;Keyboard Decode Table Vectors (8 bytes)
KEYSTD	= $eb81		;Standard Keyboard Matrix Decode Table
KEYSHFT	= $ebc2		;SHIFTed Keyboard Matrix Decode Table
KEYLOGO	= $ec03		;Commodore Logo Keyboard Matrix Decode Table
KEYCTRL	= $ec78		;Control Keyboard Matrix Decode Table
RUNTB	= $ece7		;LOAD and RUN first file on tape (SHIFT + RUN/STOP command string)
}
;target = 64

!if target = 128 {
KEYPTRS	= $c06f		;Table of default keyboard decoding table pointers (six 2-byte pointers)
			;[$c06f -> $fa80] unshifted
			;[$c071 -> $fad9] SHIFT	
			;[$c073 -> $fb32] Commodore
			;[$c076 -> $fb8b] CONTROL
			;[$c077 -> $fa80] ALT (same as unshifted)
			;[$c079 -> $fbe4] CAPS LOCK
PFKCHRS	= $c6dd		;Table of Programmable Key character values (as on VIC-20/C64)
COLOR80	= $ce5c		;Table of VDC color code translation values
PFKTBL	= $cea8		;[KEYDEFS] Table of Standard Function Key definitions
RUNTB	= $cee7		;LOAD and RUN first file on disk (function key #9 definition)
PFKEND	= $cef5		;End of Standard Function Key definitions table (+1) (10 + 67 = 77 bytes)
KEYSTD	= $fa80		;Standard Keyboard Matrix Decode Table
KEYSHFT	= $fad9		;SHIFTed Keyboard Matrix Decode Table
KEYLOGO	= $fb32		;Commodore Logo Keyboard Matrix Decode Table
KEYCTRL	= $fb8b		;Control Keyboard Matrix Decode Table
KEYCAPS	= $fbe4		;CAPS LOCK Keyboard Matrix Decode Table
}
;target = 128

!if target = 264 {
PFKCHRS	= $dc41		;[FUNTAB] Table of Programmable Key character values (as on VIC-20/C64)
KEYPTRS	= $e01e		;[KEYSETS] Keyboard Decode Table Vectors (8 bytes)
KEYSTD	= $e026		;Standard Keyboard Matrix Decode Table
KEYSHFT	= $e067		;SHIFTed Keyboard Matrix Decode Table
KEYLOGO	= $e0a8		;Commodore Logo Keyboard Matrix Decode Table
KEYCTRL	= $e0e9		;Control Keyboard Matrix Decode Table
RUNTB	= $e12a		;LOAD and RUN first file on disk (SHIFT + RUN/STOP command string)
STDCOL	= $e143		;Standard Colors Table (16 bytes)
PFKTBL	= $f3d2		;Table of Standard Function Key definitions (<F1> key modified during reset on Plus/4)
PFKEND	= $f40c		;End of Standard Function Key definitions table (+1) (8 + 50 = 58 bytes)
}
;target = 264

; --------------------
; - Kernal Jump Table
; --------------------

!if target = 264 {
;264 Series jump table for banking routines
GOBVEC	= $fcf1		;[$fcc9] ROM-map switch (cartridge entry point)
PHOENIX	= $fcf4		;[$fc59] Check for autostart cartridge and run it if found
FETCHL	= $fcf7		;[$fc7f] Long fetch routine (read a byte from a different memory BANK)
LONG	= $fcfa		;[$fc89] Long jump routine on BANK x
LNGIRQ	= $fcfd		;[$fcb8] Long IRQ routine
}

!if target = 128 {
;C128 extension to the standard CBM jump table
PHOENIX	= $ff56		;[$f867] Initialize function ROMs and attempt to boot a disk in the default drive
SETBNK	= $ff68		;[$f73f] Set data and file name Banks for I/O operations (a = data, x = file name)
JSRFAR	= $ff6e		;[$2cd] Call a subroutine in any BANK (system is always reconfigured for BANK 15 upon exit)
}

!if target = 64 | target = 128 | target = 264 {
;System calls not available on VIC-20
CINT	= $ff81		;Initialize Screen Editor (C128/264 Series: keyboard buffer not preserved)
IOINIT	= $ff84		;Initialize I/O Devices
RAMTAS	= $ff87		;Perform RAM test and set pointers to the top and bottom of RAM
}

RESTOR	= $ff8a		;Restore default I/O Vectors
SETMSG	= $ff90		;Set Message Control Flag (a = flag)
SCNKEY	= $ff9f		;Scan keyboard (result: a = keycode)
UNLSN	= $ffae		;Send UNLISTEN to a Device on the Serial Bus
LISTEN	= $ffb1		;Send LISTEN to a Device on the Serial Bus (a = device address)
SETLFS	= $ffba		;Set Logical File parameters (a = file, x = device, y = sec. address)
SETNAM	= $ffbd		;Set file name parameters (a = name length, x:y -> name string)
OPEN	= $ffc0		;Open a Logical I/O File (preparing: SETLFS, SETNAM)
CLOSE	= $ffc3		;Close a Logical I/O file (a = file)
CHKIN	= $ffc6		;Designate a Logical File As the Current Input Channel (x = file)
CHKOUT	= $ffc9		;Designate a Logical File As the Current Output Channel (x = file)
CLRCH	= $ffcc		;Restore default I/O channels
CHRIN	= $ffcf		;Input a Character from the Current Device (preparing: OPEN, CHKIN)
			;(result: a = received char (or error code), carry set = error)
CHROUT	= $ffd2		;Output Character in Accumulator to the Current Device (preparing: OPEN, CHKOUT)
			;(result: a = error code (if any), carry set = error, interrupts re-enabled)
LOAD	= $ffd5		;Load RAM from a device (a = 0: load, otherwise: verify, x:y = load address)
STOP	= $ffe1		;Test STOP Key (zero set = detected) (x, y = preserved, if not detected) 
GETIN	= $ffe4		;Get one Byte from the Input Device (result: a = received byte)
CLALL	= $ffe7		;Close all logical I/O files (and restore default I/O channels)
			;(NOTE: does not actually close any file open on tape, disk, or RS-232 device)
SCREEN	= $ffed		;Read number of Screen rows and columns (result: x = columns, y = rows)
PLOT	= $fff0		;Set/Get cursor position (CLC = set, SEC = get, x = row, y = column)
			;(C128: x not preserved, after set)
IOBASE	= $fff3		;Read base address of I/O Devices (result: x = lo-byte, y = hi-byte)

;System Vectors
NMIVEC	= $fffa		;Non-Maskable Interrupt
			;VIC-20	    -> $fea9
			;C64	    -> $fe43
			;C128	    -> $ff05
			;264 Series -> $f2a4 (emulated)
RESVEC	= $fffc		;System Reset
			;VIC-20	    -> $fd22
			;C64	    -> $fce2
			;C128	    -> $ff3d
			;264 Series -> $fff6
IRQVEC	= $fffe		;Maskable Interrupt Request and Break
			;VIC-20	    -> $ff72
			;C64	    -> $ff48
			;C128	    -> $ff17
			;264 Series -> $fcb3

; --------------------
; - Memory config
; --------------------

!if target = 20 {
!if vicmemcfg = 8 {
;VIC-20 +8k RAM (or more)
RAMBOT	= $1200		;Start of user RAM
RAMTOP	= $8000		;End of user RAM (+1)
VICSCN	= $1000		;Screen RAM address
VICCOL	= $9400		;Color RAM address

;8k expansion blocks
RAMBLK1	= $2000		;block 1
RAMBLK2	= $4000		;block 2
RAMBLK3	= $6000		;block 3
RAMBLK5	= $a000		;block 5

} else {
;VIC-20 with less than 8k expansion
RAMTOP	= $1e00		;End of user RAM (+1)
VICSCN	= $1e00		;Screen RAM address
VICCOL	= $9600		;Color RAM address

!if vicmemcfg = 3 {
;VIC-20 +3k RAM
RAMBOT	= $400		;Start of user RAM

} else {
;VIC-20 unexpanded
RAMBOT	= $1000		;Start of user RAM
}
}
}

!if target = 64 | target = 128 {
VICSCN	= $400		;Screen RAM address
VICCOL	= $d800		;Color RAM address
}

!if target = 64 {
RAMBOT	= $800		;Start of user RAM
RAMTOP	= $a000		;End of user RAM (+1)
}

!if target = 128 {
RAMBOT	= $1c00		;Start of user RAM ($4000, with graphics area allocated)
RAMTOP	= $ff00		;End of user RAM (+1)
}

!if target = 264 {
TEDCOL	= $800		;Text color RAM address
TEDSCN	= $c00		;Text screen RAM address
RAMBOT	= $1000		;Start of user RAM ($4000, with graphics area allocated)
RAMTOP	= $fd00		;End of user RAM (+1) ($4000, on C16)
}

BASTXT	= RAMBOT+1	;Start of BASIC Program Text

; --------------------
; - Symbols
; --------------------

;6502 opcodes
BIT_opcode = $24	;BIT opcode (1-byte operand) used to skip next byte
BIT2_opcode = $2c	;BIT opcode (2-bytes operand) used to skip next two bytes

!if target = 128 {
;VDC internal registers
vdc_UPDHI = $12		;[UPDATE ADDRESS HI] Current memory address (hi-byte)
vdc_UPDLO = $13		;[UPDATE ADDRESS LO] Current memory address (lo-byte)
vdc_VSCRL = $18		;[VERTICAL SMOOTH SCROLL] Vertical smooth scrolling and control register
			;bits	7 = determines whether the next block operation will be a copy or a fill
			; "	6 = reverse mode
			; "	5 = blinking rate for all characters with the flash attribute
			; "   4:0 = upward vertical smooth scrolling
vdc_COLOR = $1a		;[FORGND/BACKGND] Foreground/background color
			;bits 7:4 = foreground color for graphic or monochrome mode
			; "   3:0 = background color
vdc_COUNT = $1e		;[WORD COUNT] Number of bytes for block write or copy (auto incrementing address)
vdc_DATA = $1f		;[DATA] Memory read/write (auto incrementing address)
}

; --------------------
; - Keyboard & chars
; --------------------

SHIFT = $80		;SHIFT key modifier

;PETSCII chars
space_char = $20	;space char
quote_char = $22	;quotation mark (")
up_arrow = $5e		;upwards arrow (^)
left_arrow = $5f	;leftwards arrow (<-)
line_char = $c0		;light horizontal line

;Cursor keys
CRSR_down = $11		;cursor down
CRSR_right = $1d	;cursor right
CRSR_up	= $91		;cursor up
CRSR_left = $9d		;cursor left

;Function keys (8 values)
FNKEY = [$85,$89,$86,$8a,$87,$8b,$88,$8c]

F1_char = $85
F3_char = $86
F5_char = $87
F7_char = $88
F2_char = $89
F4_char = $8a
F6_char = $8b

!if target = 264 {
HELP_char = $8c		;HELP (function key #8)

} else {
F8_char = $8c
}

RUN_char = $83		;RUN (SHIFT + RUN/STOP) (C128: function key #9)

!if target = 128 {
HELP_char = $84		;HELP (function key #10)
}

;Control keys
STOP_char = $03		;RUN/STOP key
RETURN_char = $0d	;RETURN key (ENTER)
HOME_char = $13		;HOME key
CLR_char = $93		;clear screen (SHIFT + HOME)
DEL_char = $14		;delete (backspace)
RVS_on = $12		;reverse on
RVS_off = $92		;reverse off

!if target = 128 | target = 264 {
ESC_char = $1b		;ESC (escape)
}

; --------------------
; - BASIC tokens
; --------------------

;BASIC 2.0
REM_tok	= $8f		;REM command
LOAD_tok = $93		;LOAD command
CLR_tok	= $9c		;CLR command (C128/264 Series: GRAPHIC argument)
SYS_tok	= $9e		;SYS command

!if target = 128 | target = 264 {
;BASIC 3.5 and 7.0
GRAPHIC_tok = $de	;GRAPHIC command
}

!if target = 128 {
;BASIC 7.0
BANK_tok = $02		;BANK command (dual token)
FN_prefix = $ce		;dual token function prefix
CMD_prefix = $fe	;dual token command prefix
}
;target = 128

;Operators
ADD_tok = $aa		;add
SUB_tok = $ab		;subtract
MULT_tok = $ac		;multiply
DIV_tok = $ad		;divide
EXP_tok = $ae		;exponentiate
AND_tok = $af		;logical AND
OR_tok = $b0		;logical OR
GREAT_tok = $b1		;greater than
EQUAL_tok = $b2		;equal to
LESS_tok = $b3		;less than

; --------------------
; - Screen consts
; --------------------

;Screen size
!if target = 20 {
SCNCOLS	= 22
SCNROWS	= 23

} else {
SCNCOLS	= 40
SCNROWS	= 25
}

!if target = 128 {
;VDC 80-column mode
VDCCOLS	= 80
VDCROWS	= 25
}

;ASCII color codes (16 values)
ASCCOL = [$90,$05,$1c,$9f,$9c,$1e,$1f,$9e,$81,$95,$96,$97,$98,$99,$9a,$9b]

;code	VIC-20		C64/C128	C128 (VDC)	RGBI		monochrome	264 Series	luma/color
; 0	black		black		black		0000 = $00	black		black		$00
; 1	white		white		white		1111 = $0f	white		white		$71
; 2	red		red		dark red	1000 = $08	gray		red		$32
; 3	cyan		cyan		light cyan	0111 = $07	white		cyan		$63
; 4	purple		purple		light purple	1011 = $0b	white		purple		$44
; 5	green		green		dark green	0100 = $04	gray		green		$35
; 6	blue		blue		dark blue	0010 = $02	gray		blue		$46
; 7	yellow		yellow		light yellow	1101 = $0d	white		yellow		$77
; 8	orange		orange		dark purple	1010 = $0a	gray		orange		$48
; 9	light orange	brown		dark yellow	1100 = $0c	gray		brown		$29
;10	pink		light red	light red	1001 = $09	white		yellow green	$5a
;11	light cyan	dark gray	dark cyan	0110 = $06	gray		pink		$6b
;12	light purple	medium gray	medium gray	0001 = $01	black		blue green	$5c
;13	light green	light green	light green	0101 = $05	white		light blue	$6d
;14	light blue	light blue	light blue	0011 = $03	white		dark blue	$2e
;15	light yellow	light gray	light gray	1110 = $0e	gray		light green	$5f

; --------------------
; - Joystick switches
; --------------------

;	VIC-20		C64/C128	264 Series
;port	VIAPRA	VI2PRB	CIAPRB	CIAPRA	TEDKEY
;bit	(single input)	joy #1	joy #2	joy #1	joy #2
;0	-	-	up	up	up	up
;1	-	-	down	down	down	down
;2	up	-	left	left	left	left
;3	down	-	right	right	right	right
;4	left	-	fire	fire	-	-
;5	fire	-	-	-	-	-
;6	-	-	-	-	fire	-
;7	-	right	-	-	-	fire

;NOTE: if a switch is pressed, the corresponding bit will be 0

;On 264 Series, before reading joystick input:
;disable keyboard (temporarily) writing $ff to PIOKEY ($fd30)
;select joystick port writing corresponding latch value to TEDKEY ($ff08)

;port	joy #1	joy #2
;bit	2	1
;latch	$fb	$fd

;NOTE: official value to latch joystick port #1 is $fa, but a value of $fb would be more correct

; --------------------
; - Usable locations
; --------------------

;VIC-20 and C64
;$12		TANSGN	1	Flag: Sign of the Result of the TAN or SIN Function
;$14-$15	LINNUM	2	Integer Line Number Value
;$1c-$21	TEMPST	6	Descriptor Stack for Temporary Strings (part of $19-$21) ($19-$1b used by PRNINT)
;$26-$2a	RESHO	5	Floating Point Multiplication Work Area
;$39-$3a	CURLIN	2	Current BASIC Line Number
;$3b-$3c	OLDLIN	2	Previous BASIC Line Number
;$3f-$40	DATLIN	2	Current DATA Line Number
;$43-$44	INPPTR	2	Pointer to the Source of GET, READ, or INPUT Information
;$45-$46	VARNAM	2	Current BASIC Variable Name
;$48		VARPNT	1	Pointer to the Current BASIC Variable Value (part of $47-$48) ($47 used by FOUT)
;$49-$4a	FORPNT	2	Temporary Pointer to the Index Variable Used by FOR
;$4b-$4c	OPPTR	2	Math Operator Table Displacement
;$4d		OPMASK	1	Mask for Comparison Operation
;$4e-$4f	DEFPNT	2	Pointer to the Current FN Descriptor
;$57-$5c	TEMPF3	6	BASIC Numeric Work Area (part of $57-$60) ($5d-$5e used by PRNINT)
;$5f-$60	 "	2	 "
;$61-$65	FAC1	5	Floating Point Accumulator #1
;$66		FACSGN	1	Floating Point Accumulator #1: Sign
;$67		SGNFLG	1	Number of Terms in a Series Evaluation
;$68		BITS	1	Floating Point Accumulator #1: Overflow Digit
;$69-$6d	FAC2	5	Floating Point Accumulator #2
;$6e		ARGSGN	1	Floating Point Accumulator #2: Sign
;$6f		ARISGN	1	Result of a Sign Comparison of Accumulator #1 to Accumulator #2
;$70		FACOV	1	Low Order Mantissa Byte of Floating Point Accumulator #1 (for rounding)
;$97		XSAV	1	Temporary .X Register Save Area
;$f7-$f8	RIBUF	2	Pointer to RS-232 Input Buffer
;$f9-$fa	ROBUF	2	Pointer to RS-232 Output Buffer
;$fb-$fe	FREKZP	4	Four free bytes of Zero Page for user programs
;$334-$33b	USRCMDS	8	Eight free bytes for user vectors or other data
;$33c-$3fb	TBUFFR	192	Cassette I/O Buffer
;$3fc-$3ff	-	4	Four bytes of unused area

;VIC-20 only
;$00		USRPOK	1	Jump Instruction for User Function (default = $4c)
;$01-$02	USRADD	2	Address of USR Routine (LSB/MSB) (default = $d248)
;$2a1-$2ff	-	95	[USRVCTRS] Unused
;$310-$313	PG3FREE	4	Unused

;C64 only
;$02		-	1	Unused
;$251-$258	BUF	8	BASIC Line Editor Input Buffer (part of $200-$258)
;$2a7-$2ff	-	89	Unused
;$310		USRPOK	1	Jump instruction for User Function (default = $4c)
;$311-$312	USRADD	2	Address of USR Routine (LSB/MSB) (default = $b248)
;$313		-	1	Unused

;C128
;$1e-$23	TEMPST	6	Descriptor Stack for Temporary Strings (part of $1b-$23)
;$28-$2c	RESHO	5	Floating Point Multiplication Work Area
;$50-$51	TEMPF3	2	Temporary storage for floating-point value (part of $50-$54)
;$54		 "	1	 "
;$55		HELPER	1	HELP flag (LIST/HELP)
;$59-$5d	TEMPF1	5	Floating-point work area
;$5e	 	TEMPF2	1	Temporary storage for floating-point value (part of $5e-$62)
;$63-$67	FAC1	5	Floating-point accumulator 1
;$68		FACSGN	1	Sign of FAC1
;$69		SGNFLG	1	Sign flag during conversion / Count of terms in series evaluation
;$6a-$6e	FAC2	5	Floating-point accumulator 2
;$6f		ARGSGN	1	Sign of FAC2
;$70		ARISGN	1	Sign comparison flag
;$71		FACOV	1	Rounding flag for FAC1
;$74-$75	AUTINC	2	Step value for autoincrement
;$87-$88	SCALE_X	2	Horizontal scaling factor
;$89-$8a	SCALE_Y	2	Vertical scaling factor
;$97		XSAV	1	Temporary register storage
;$c8-$c9	RIBUF	2	Pointer to RS-232 Input Buffer
;$ca-$cb	ROBUF	2	Pointer to RS-232 Output Buffer
;$ce-$cf	IMPARM	2	Pointer for Kernal PRIMM routine
;$fa		-	1	Unused. Overwritten by CINT ($c07b) and SWAPPER ($cd2e) routines
;$fb-$fe	FREKZP	4	Four Free Bytes of Zero Page for User Programs
;$ac5		DK_FLAG	1	Reserved for foreign screen editors. Unused by any routine in the U.S. version of the system ROMs
;$ac6-$aff	-	58	Reserved for system use. Unused by any routine in the current version of the system ROMs
;$b00-$bff	TBUFFR	256	Cassette I/O Buffer ($b00-$bbf, 192 bytes) and Disk Boot Buffer ($b00-$bff, 256 bytes)
;$c00-$cff	RS232I	256	RS-232 Input Buffer
;$d00-$dff	RS232O	256	RS-232 Output Buffer
;$e00-$fff	-	256	Sprite Pattern Storage Area
;$1000-$1009	PKYBUF	10	Programmable Function Key lengths table for 10 keys (F1..F8, LOAD/RUN, HELP)
;$100a-$10ff	PKYDEF	246	Programmable Function Key strings
;$1100-$1130	DOSSTR	49	DOS command assembly area
;$1131-$1132	XPOS	2	Bitmapped-screen pixel-cursor horizontal position
;$1133-$1134	YPOS	2	Bitmapped-screen pixel-cursor vertical position
;$1218		USRPOK	1	Jump instruction for User Function (default = $4c)
;$1219-$121a	-	2	Address of USR Routine (LSB/MSB) (default = $7d28)

;264 Series
;$1c-$21	TEMPST	6	Descriptor Stack for Temporary Strings (part of $19-$21)
;$26-$2a	RESHO	5	Floating Point Multiplication Work Area
;$57-$5c	TEMPF1	6	BASIC Numeric Work Area (part of $57-$60)
;$d0-$d7	SPEECH	8	Data addresses for speech
;$d8-$e8	FREKZP	17	Free zero-page area
;$fc-$fd	RS232	2	X-on/X-off character mode for RS232 I/O (free on C16)
;$2f6-$2fd	-	8	Free
;$32c-$32d	USRCMD	2	Free vector
;$332-$3f2	TBUFFR	193	Cassette I/O Buffer
;$3f3-$3f4	WRLEN	2	Length of data to be written to tape
;$3f5-$3f6	RDCNT	2	Length of data to be read from tape
;$3f7-$436	INPQUE	64	RS-232 buffer (free on C16)
;$437-$454	ESTARL	30	Cassette I/O error stack (low bytes)
;$455-$472	ESTAKH	30	Cassette I/O error stack (high bytes)
;$500		USRPOK	1	Jump instruction for User Function (default = $4c)
;$501-$502	USRADD	2	Address of USR Routine (LSB/MSB) (default = $991c)
;$53d		-	1	Free
;$55f-$566	PKYBUF	8	[KEYBUF] Table of lenghts of Function Keys definitions (F1..F7, HELP)
;$567-$5e6	PKYDEF	128	[PKYBUF] Function Keys definitions strings
;$609-$65d	AREAS	85	Banking RAM area (?)
;$65e-$6eb	ASPECH	142	RAM reserved for speech software (never used)
;$7fe-$7ff	-	2	Free
;$be8-$bff	-	24	Free
;$fe8-$fff	-	24	Free
